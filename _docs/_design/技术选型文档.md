
# 智能旅游APP — 技术选型与实现方案

> 后端：**FastAPI + LangGraph**
>
> 前端：**Android (Kotlin) + Jetpack Compose + MVVM + Retrofit + 高德 SDK**

---

## 目录（快速导航）

1. 目标概述与约束
2. 总体架构（逻辑视图）
3. 后端详细设计（FastAPI + LangGraph）
   * 服务分层与模块
   * 数据模型（Pydantic / DB schema）
   * 关键 API 规范与示例（含请求/响应）
   * LangGraph 智能体设计（节点、流程、示例 prompt + 输出结构）
   * 异步、并发、缓存策略
   * 安全、鉴权、配额限制
4. 前端详细设计（Android + Compose + MVVM）
   * 架构与模块划分
   * 页面/组件清单与交互说明
   * 本地持久化（Room）数据模型
   * Retrofit 接口示例 + WebSocket 智能助手集成
   * 高德地图集成要点（定位、POI、绘制路线、跳转导航）
5. 集成场景与端到端流程（序列/时序说明）
6. 部署、运维与监控建议
7. 测试、验收标准与关键里程碑
8. 风险、替代方案与扩展点

---

## 1. 项目目标与约束

* **目标** ：实现“行前规划（含智能生成）→ 行中发现 → 行程助手”闭环，支持用户创建/编辑/拖拽行程卡片、地图 POI 展示、LLM 驱动的智能行程生成与多轮问答。
* **约束** ：前端固定 Android 原生；后端固定 Python；LangGraph 用于智能体/工具调用流程编排；需支持异步 LLM 调用与流式回复（用于聊天/生成反馈）。
* **非目标** ：不在本阶段实现完整支付/第三方订票接口（可作为后期扩展）。

---

## 2. 总体架构（逻辑视图）

```
Android App (Compose + MVVM)
 ├─ UI 层（Trip Planner / Map / Assistant）
 ├─ ViewModel 层（TripVM, MapVM, AssistantVM）
 └─ Data 层（Retrofit → FastAPI, Room 本地缓存）

FastAPI 后端
 ├─ API 层 (/api/trips, /api/poi, /api/assistant, /ws/assistant)
 ├─ 服务层（TripService, POIService, AIService）
 ├─ LangGraph 智能体层（Agent 管理 + Node 流程）
 ├─ DB 层（SQLAlchemy + MySQL/SQLite）
 ├─ Cache（Redis）
 └─ 外部 API（高德地图 Web 服务 / 天气 / LLM 提供商）
```

---

## 3. 后端详细设计（FastAPI + LangGraph）

### 3.1 服务分层与模块

* `api/` —— FastAPI 路由（REST + WebSocket）
* `core/` —— 应用启动、配置、依赖注入（DI）
* `services/` —— 业务逻辑（TripService、PoiService、AIService）
* `agents/` —— LangGraph 图定义、节点实现（PlannerNode、PoiNode、WeatherNode、AssistantNode、MemoryNode）
* `models/` —— Pydantic 请求/响应模型 + ORM（SQLAlchemy）实体
* `utils/` —— 外部 API 封装（高德、天气、LLM 客户端）、缓存、限流、日志
* `db/` —— DB 会话管理、迁移脚本（Alembic）

### 3.2 数据模型（Pydantic + ORM 概览）

（关键字段示例，简化以便阅读）

**Pydantic 模型（示例）**

```python
# models/schemas.py
from pydantic import BaseModel
from typing import List, Optional

class SubTripSchema(BaseModel):
    order: int
    activity: str
    location_name: str
    note: Optional[str]
    transport: Optional[str]  # walk/bike/drive/transit
    lat: Optional[float]
    lng: Optional[float]

class DayCardSchema(BaseModel):
    day_index: int
    date: Optional[str]  # ISO date
    sub_trips: List[SubTripSchema]

class TripSchema(BaseModel):
    id: Optional[int]
    user_id: int
    destination: str
    start_date: str
    end_date: str
    day_cards: List[DayCardSchema]
```

**关系型 DB（简要）**

* `users`：id, name, email, preferences
* `trips`：id, user_id, destination, start_date, end_date, created_at
* `day_cards`：id, trip_id, day_index, date
* `sub_trips`：id, day_card_id, order_index, activity, loc_name, note, transport, lat, lng

### 3.3 关键 API 设计（示例）

> 注意：所有 REST 接口均返回标准 JSON：`{ "code": 0, "msg": "ok", "data": {...} }`

**1) 行程 CRUD**

* `GET /api/trips` — 获取用户所有行程（支持分页）
* `GET /api/trips/{trip_id}` — 获取单个行程详情（包含 day_cards/sub_trips）
* `POST /api/trips` — 创建行程（请求体 TripSchema）
* `PUT /api/trips/{trip_id}` — 更新行程（全量或部分）
* `DELETE /api/trips/{trip_id}` — 删除行程

**示例：POST /api/trips**

请求体（JSON）：

```json
{
  "user_id": 123,
  "destination": "杭州",
  "start_date": "2025-12-01",
  "end_date": "2025-12-03",
  "day_cards": [
    {
      "day_index": 1,
      "date": "2025-12-01",
      "sub_trips": [
        {
          "order": 1,
          "activity": "西湖游船",
          "location_name": "西湖",
          "note": "上午9点出发",
          "transport": "walk",
          "lat": 30.244,
          "lng": 120.153
        }
      ]
    }
  ]
}
```

响应：

```json
{ "code":0, "msg":"ok", "data":{"trip_id": 456} }
```

**2) POI / 周边搜索**

* `GET /api/poi/around?lat=..&lng=..&type=food&radius=2000` — 返回 POI 列表（来自高德/缓存）

**3) 智能生成行程（两种模式）**

* `POST /api/ai/plan` — 生成建议行程

  请求体：

  ```json
  {
    "mode": "deep" | "fast",
    "destination": "杭州",
    "start_date": "2025-12-01",
    "end_date": "2025-12-03",
    "preferences": {"interest":["museum","food"], "budget":"medium"}
  }
  ```

  返回：标准化 `TripSchema` JSON。

**4) 智能助手 Chat（WebSocket 流式/REST 单轮）**

* `ws://{host}/ws/assistant?user_id=123` — WebSocket 持久连接，用于流式回复；
* `POST /api/ai/chat` — 单轮问答（返回完整回答或建议步骤）。

### 3.4 LangGraph 智能体设计（节点/流程）

目标：使用 LangGraph 作为“智能体编排/工具调用”层，把 LLM 的文本输出映射为结构化工具调用（如 POI 查询、规则规划、行程合并）。

**核心智能体（示例）**

* `AssistantNode`（入口）：解析用户意图（NLU），决定调用 Planner/POI/Weather/DB。
* `PlannerNode`：基于目的地/日期/偏好，生成初步行程 —— 可能先调用规则引擎（distance/time constraints），再调用 LLM 得到更自然的建议。
* `PoiNode`：调用高德周边搜索接口，返回可插入的 POI 列表（含评分/图片）。
* `WeatherNode`：获取日期范围内天气，给出建议（是否调整户外活动）。
* `MemoryNode`：存储/读取会话上下文（Redis），用于多轮对话记忆。

**LangGraph 流示例（伪码）**

```python
graph = LangGraph()
graph.add_node("assistant", assistant_handler)
graph.add_node("intent_parser", parse_intent)
graph.add_node("planner", planner_node)
graph.add_node("poi", poi_node)
graph.add_edge("assistant", "intent_parser")
graph.add_edge("intent_parser", "planner", condition="intent == 'plan_trip'")
graph.add_edge("planner", "poi", condition="needs_poi")
graph.add_edge("planner", "response_formatter")
```

**LLM Prompt 模板（行程生成）**

```
System: 你是旅行行程生成助手。输出必须为严格的 JSON，格式如下：{ "days": [ { "day_index": 1, "sub_trips": [ { "order":1, "activity":"", "location":"", "start_time":"", "end_time":"", "note":"" } ] } ] }
User: 目的地: {destination}，日期: {start_date} 到 {end_date}，兴趣: {interests}，预算: {budget}。请生成每天的活动安排，考虑地理路程和开放时间。
```

> LLM 输出必须经过 `response_validator` 节点（校验字段、坐标格式），若不合规则重试/回退到规则生成。

### 3.5 异步、并发与缓存策略

* **框架** ：FastAPI + Uvicorn (ASGI)；所有 IO 操作（高德API、LLM、天气）用 `async` + `httpx`。
* **并发控制** ：为避免被 LLM/地图API 限流，使用异步限流器（如 `asyncio.Semaphore` 或 Redis-based rate limiter）。
* **任务队列** ：对于耗时生成（深度模式），提供异步任务（后台任务或 Celery），并通过 WebSocket 或轮询返回结果。
* **缓存** ：POI、路线结果及 LLM 中间结果可缓存于 Redis（TTL 5–60min），减少重复调用并提高响应速度。
* **流式回复** ：对于聊天助手，后端通过 WebSocket 推送 LLM 的分片 token（支持前端逐字/逐块显示）。

### 3.6 鉴权与安全

* **身份** ：简化可用 JWT（短期）或 session token；所有写操作需鉴权。
* **API Key 管理** ：外部服务 Key（高德、LLM）只在后端保存，不暴露给客户端。
* **防滥用** ：对 AI 接口使用速率限制与配额（每用户/每分钟请求数）。
* **输入校验** ：所有外部输入均使用 Pydantic 校验，且对 LLM 输出做白名单字段校验。
* **日志与审计** ：记录用户发起的“生成/修改”行为（用于论文复现与问题追踪）。

---

## 4. 前端详细设计（Android + Jetpack Compose + MVVM）

### 4.1 架构与模块

* **UI 层（Compose）** ：Screen 组件（Home、TripPlanner、TripEditor、MapDiscover、Assistant、TripDetail）
* **ViewModel 层** ：`TripViewModel`, `MapViewModel`, `AssistantViewModel`（使用 Kotlin Coroutines + StateFlow）
* **Repository 层** ：`TripRepository`（Retrofit + 本地 Room 缓存 + sync 逻辑）
* **Network** ：Retrofit + OkHttp + Converter（Moshi/Gson）
* **DB** ：Room（实体映射 Trip/DayCard/SubTrip）
* **依赖注入** ：Hilt（依赖注入方便测试/Mock）
* **图片/媒体** ：Coil（Compose 原生支持）

### 4.2 页面与交互要点

* **行程卡片页（TripPlanner）** ：使用 Compose `LazyColumn` + 卡片组件；**拖拽**使用 Compose DragGesture 或在 RecyclerView 方案下使用 `ItemTouchHelper`。用户增删改子行程，顺序变更后调用 ViewModel 保存并请求后端更新（乐观更新 + 回退策略）。
* **智能生成流程** ：用户触发生成 → 显示 “生成中” 动画（Lottie）→ 若为深度模式：后台生成完成通过 WebSocket/轮询通知 → 前端接收并在可编辑模式下展示生成的 day_cards。
* **地图页** ：集成高德 MapView，展示用户定位、POI 标记（可根据类型分组图标），Marker 点击弹出 BottomSheet 显示 POI 详情（图片、地址、评分、加入行程按钮）。
* **智能助手（浮窗）** ：右下固定 FloatingActionButton；点击展开对话界面（Compose）；对话消息使用 `LazyColumn` 展示；发送中使用 WebSocket 接收流式回应并实时渲染。
* **导航跳转** ：构造 Intent 打开高德/百度导航（若检测到用户设备中安装相应 App）。

### 4.3 本地数据模型（Room 实体示例）

```kotlin
@Entity(tableName = "trips")
data class TripEntity(
  @PrimaryKey val id: Long,
  val userId: Long,
  val destination: String,
  val startDate: String,
  val endDate: String
)

@Entity(tableName = "sub_trips")
data class SubTripEntity(
  @PrimaryKey(autoGenerate = true) val id: Long,
  val tripId: Long,
  val dayIndex: Int,
  val orderIndex: Int,
  val activity: String,
  val locationName: String,
  val note: String?,
  val transport: String?,
  val lat: Double?,
  val lng: Double?
)
```

### 4.4 Retrofit 接口与示例（Kotlin）

```kotlin
interface ApiService {
  @GET("api/trips")
  suspend fun getTrips(@Query("user_id") userId: Long): ApiResponse<List<TripDto>>

  @POST("api/trips")
  suspend fun createTrip(@Body trip: TripDto): ApiResponse<CreateTripResult>

  @GET("api/poi/around")
  suspend fun poiAround(@Query("lat") lat: Double, @Query("lng") lng: Double,
                        @Query("type") type: String, @Query("radius") radius: Int): ApiResponse<List<PoiDto>>
}
```

### 4.5 WebSocket 用于智能助手（示例）

* 使用 OkHttp 的 `WebSocket` 或 `Ktor` 客户端实现持久连接。
* 连接参数 `/ws/assistant?user_id=123&session_id=xxx`；
* 客户端发送：`{ "type":"user_msg", "text":"帮我生成杭州三日游" }`
* 服务端流式返回若干 `message` 帧：每帧包含 token 或 partial_text，前端拼接显示。

### 4.6 高德 SDK 集成要点

* SDK 权限：定位权限（前台/后台按需求），网络权限。
* 高德地图主要模块：`MapView`、`LocationClient`、POI 搜索（Web API 或 SDK Search）、路线规划（驾车/步行/公共交通）绘制。
* 若需要跳转高德导航：构造高德地图导航 Intent（或通过高德提供的 URL Scheme）。

---

## 5. 集成场景与端到端流程（示例序列）

### 场景 A — 用户请求深度生成行程

1. Android 前端发送 `POST /api/ai/plan`（mode=deep）
2. FastAPI 接收请求 → 创建 LangGraph 会话（生成 session_id）
3. LangGraph AssistantNode 调用 PlannerNode 与 PoiNode：
   * PlannerNode 构造 LLM prompt，异步调用 LLM；
   * PoiNode 并行调用高德 POI API 补充坐标与营业时间；
4. PlannerNode 校验 LLM 输出（response_validator）；不合规则重试/退回简单规则。
5. 生成完成，保存 DB，推送事件到 Redis + WebSocket（或前端轮询到结果）。
6. 前端接收并渲染可编辑行程卡片。

### 场景 B — 智能助手对话（多轮）

1. 前端通过 WebSocket 发送问题“帮我把第一天行程改成更轻松一点”
2. 服务端 AssistantNode 读取 MemoryNode（当前行程上下文），生成改动建议（调用 PlannerNode）
3. 服务端流式返回修改后的 sub_trips，前端展示并提示“是否保存到行程？”。

---

## 6. 部署、运维与监控建议

* **运行环境** ：Uvicorn + Gunicorn (workers) 或 Uvicorn + Process Manager；使用 ASGI 支持 WebSocket 与异步。
* **进程/线程** ：推荐多进程（Gunicorn workers）配合 async 提升并发。
* **缓存/状态** ：Redis 用于会话上下文与 LangGraph 状态短期存储。
* **监控** ：Prometheus + Grafana（请求速率、LLM 调用耗时、CPU/内存、Redis 命中率）。
* **日志** ：结构化日志（JSON），记录 request_id、user_id、latency、llm_provider_response_id。
* **CI/CD** ：GitHub Actions 或 GitLab CI，包含单元测试、静态检查（flake8/black）、构建镜像。
* **备份/迁移** ：使用 Alembic 管理 DB 迁移，定期备份用户数据（若使用托管 DB，请遵守隐私规范）。

---

## 7. 测试、验收标准与里程碑

### 测试类型

* 单元测试（后端服务函数/前端 ViewModel）
* 集成测试（FastAPI 路由 + DB + LangGraph 模拟）
* E2E（Android 客户端与后端联调）
* 性能测试（并发 LLM 调用场景模拟）
* 安全测试（鉴权、速率限制、输入校验）

### 验收标准（示例）

* 行程 CRUD 正常，创建/编辑/删除操作 100% 可行。
* 智能生成（普通模式）在 90% 情况下给出合规 JSON（字段齐全）。
* 智能助手 WebSocket 连续流式返回帧，前端能顺序拼接显示（无明显卡顿）。
* 地图页面可展示当前位置与周边 POI（响应时间 < 1s for cache, <2s for fresh）。
* 必要的安全措施到位（后端 Key 未暴露，API 鉴权生效）。

### 开发里程碑（建议）

1. 第1–2 周：接口与原型（Compose）实现（静态数据）
2. 第3–4 周：FastAPI 基本 CRUD + Room 本地持久化
3. 第5–6 周：高德 SDK 集成、POI 搜索、地图 UI
4. 第7–8 周：LangGraph 基础图 + 普通规则行程生成功能
5. 第9–10 周：LLM 集成（深度模式）+ WebSocket 聊天流式显示
6. 第11 周：联调、性能测试、论文撰写、答辩准备

---

## 8. 风险、替代方案与扩展点

### 风险

* LLM 调用延迟/限流或成本超预算 → 需提供规则回退（快速模式）；对成本严格监控与缓存。
* 第三方 API（高德）配额限制 → 缓存/本地化数据策略或提供降级体验。
* 多轮上下文一致性问题 → MemoryNode + 短期会话上下文与工具校验。

### 替代方案

* 若 LLM 不可用：使用本地规则引擎（distance/time heuristics + POI ranking）生成可编辑行程。
* 若高德 SDK 不可用：切换百度地图或使用 WebView Map。

### 扩展点（后续）

* 语音交互（讯飞/Google Speech）
* 票务/酒店一键预订接入
* 用户画像 + 个性化推荐（基于历史行程聚类）
* 离线模式（缓存地图切片 & 行程）

---

## 附录：代码/接口示例速查

### FastAPI 路由示例（伪码）

```python
from fastapi import FastAPI, WebSocket, Depends
app = FastAPI()

@app.post("/api/ai/plan")
async def ai_plan(payload: PlanRequest):
    # create langgraph session, schedule Node, return session_id or trip
    ...

@app.websocket("/ws/assistant")
async def ws_assistant(ws: WebSocket, user_id: int):
    await ws.accept()
    while True:
        msg = await ws.receive_json()
        # forward to LangGraph assistant node, stream back tokens
        ...
```

### LangGraph Node（伪码）

```python
async def planner_node(state):
    prompt = build_prompt(state)
    llm_resp = await llm_client.generate(prompt)
    json_trip = validate_and_parse(llm_resp)
    return json_trip
```

### Android ViewModel（伪码）

```kotlin
class TripViewModel @Inject constructor(
  private val repo: TripRepository
): ViewModel() {
  val uiState = MutableStateFlow(TripUiState())

  fun generateTripDeep(destination: String, start: String, end: String) {
    viewModelScope.launch {
      uiState.update { it.copy(loading = true) }
      val resp = repo.aiPlanDeep(destination, start, end)
      uiState.update { it.copy(loading=false, trip = resp.data) }
    }
  }
}
```

---

## 最后（结论 & 建议）

* **首选实现路线** ：采用 **FastAPI + LangGraph** 作为后端智能层，**Android + Jetpack Compose + MVVM + Retrofit + 高德 SDK** 作为前端栈——这一组合在性能、可演示性、论文阐述维度都非常平衡，适合本科毕设并具备进一步扩展能力。
* **推荐开发顺序** ：先实现“行程 CRUD + 地图 POI 展示 + 流程化规则生成（快速模式）”，随后并行接入 LangGraph 的 LLM 深度生成与 WebSocket 聊天流式功能。这样能保证中期演示的完整性，同时留出充足时间集成与调优智能体。
