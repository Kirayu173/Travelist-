### 阶段4：LLM Provider 层 + mem0 接入 + AI 基础监控（智能体底座）

 **目标** ：后端先搭出一个可复用的“智能层 SDK”：统一 LLM 调用、引入 mem0 做记忆层，并且在 Admin 面板看到 AI 调用的基本指标。

* Spec：
  * 设计 `AiClient` 抽象层，封装不同 LLM Provider；
  * 设计 `MemoryService`，基于 mem0 的 Python SDK，支持：
    * `write_memory(user_id, level, data, metadata)`
    * `search_memory(user_id, level, query, k)` 等；
  * 约定多级记忆的编码方式（user / trip / session）。
* Code：
  * 引入 `mem0ai` 依赖并完成最小使用 Demo；
  * 实现 `AiClient`（以一个主模型为起点即可）；
  * 在 FastAPI 中增加 `/api/ai/chat_demo`，只做简单问答 + 记忆写入 / 读取；
  * 在 /admin 增加 `/admin/ai/summary`：统计 LLM 调用次数、平均耗时、错误率。
* Review：
  * 保证在不依赖 LangGraph 的前提下，能完整跑通「问题 → LLM → mem0 写入 → 再问 → mem0 检索」这一条链；
  * 在后台管理界面中增添AI对话框，能够实时测试LLM问答功能
  * Admin 中能看到 AI 调用指标在变化。

---

### 阶段5：LangGraph 智能助手 v1（单轮问答 + 多级记忆）

 **目标** ：在阶段4的基础上，用 LangGraph 把“意图分析 + 工具调用 + 记忆读写”串成一张最小可用的图，先实现**单轮 REST 问答**版本的行程助手。

* Spec：
  * 定义第一版 Graph：
    * `AssistantNode`：入口，负责把 user input 转成 internal state；
    * `MemoryReadNode`：基于 mem0 搜索相关记忆；
    * `TripQueryNode`：访问 PostgreSQL 中 trips/day_cards/sub_trips，回答“我明天的行程是什么”这类问题；
    * `ResponseFormatter`：把结构化结果包装成自然语言；
  * 确定状态流转和错误回退策略。
* Code：
  * 引入 LangGraph，按上面 Spec 搭建图；
  * 实现 `POST /api/ai/chat`（单轮）：
    * 调用 LangGraph 完整流程；
    * 在结束时把对话摘要写入 mem0（会话级记忆）。
  * 在 `/admin/chat/summary` 统计：调用次数、常见意图分布（intent 简单存数据库 / Redis 后汇总）。
* Review：
  * 能回答与**已有结构化数据**相关的问题（例如当前行程），证明“LangGraph + mem0 + DB”这套组合在逻辑上跑得通；
  * 行为和日志可解释，便于以后写到论文“智能体编排”章节。

---

### 阶段6：POI & 地理服务 + Redis 缓存（为智能规划准备工具层）

 **目标** ：补齐“附近发现 / POI 检索”能力，并把它作为 LangGraph 工具的一部分，为后续智能行程规划做准备。

* Spec：
  * 设计 `/api/poi/around` 接口参数与返回结构；
  * 设计 Redis 缓存 key（`poi:around:lat:lng:type:radius`）和 TTL；
  * 将 `PoiNode` 纳入 LangGraph，作为可调用工具。
* Code：
  * 实现 POI 服务：
    * 缓存 → 本地 pois 表 → 回源高德 API 的 cache-aside 流程；
  * Admin 增加 `/admin/poi/summary`：
    * POI 表数据量、缓存 hit/miss、第三方调用次数。
* Review：
  * 手动调用 `/api/poi/around` 验证缓存行为正确；
  * `PoiNode` 能被 LangGraph 调起来并返回合理的 POI 列表。

---

### 阶段7：行程规划 Fast 模式（规则版）+ LangGraph Planner

 **目标** ：在不依赖 LLM 的前提下，先实现可靠的规则规划模式（mode=fast），并把 `PlannerNode` 完整纳入 LangGraph。

* Spec：
  * 规划规则：
    * 结合 POI 距离、时间、兴趣标签，按天/半天分配；
  * 定义 `POST /api/ai/plan` 的请求/响应结构（沿用你技术选型文档里的 TripSchema）。
* Code：
  * 实现 `FastPlanner`（纯规则）；
  * 将 `PlannerNode` 接入 LangGraph 流程，在 `mode=fast` 时只走规则路径；
  * Admin `/admin/plan/summary`：统计 fast 模式调用次数、平均行程天数、失败率等。
* Review：
  * 对多个城市 / 日期段测试，保证至少能稳定生成结构合理的行程（哪怕不“很聪明”也要“绝对靠谱”）。

---

### 阶段8：行程规划 Deep 模式 + 异步任务（ai_tasks）

 **目标** ：让 LLM 正式参与行程规划，在规则规划基础上叠加“深度思考模式”，并通过异步任务体系控制成本和延迟。

* Spec：
  * 在 LangGraph 中扩展 `PlannerNode`：
    * `fast`：只规则；
    * `deep`：规则 + LLM 微调，或者直接 LLM 生成再校验结构；
  * 设计 `ai_tasks` 表结构和状态流转（pending / running / done / failed）。
* Code：
  * 实现 `mode=deep` 时的 LLM 调用 + JSON 结构校验（与后端设计文档保持一致）；
  * 引入后台任务执行器（可以先用 arq / 自建协程队列）；
  * `/api/ai/plan` 支持 `async=true` 返回 `task_id`；
  * `/admin/ai/tasks` 展示任务状态分布。
* Review：
  * 至少完成一组“fast vs deep”的对比，用于以后论文实验；
  * 能通过 mem0 记录“用户偏好”和多次 deep 规划之间的差异（个性化）。

---

### 阶段9：行程助手多轮对话（REST + WebSocket）+ 会话持久化

 **目标** ：把智能体升级成真正的“行程助手”：支持多轮对话、工具调用、mem0 长期记忆，并通过 WebSocket 流式回复。

* Spec：
  * WebSocket 路由：`/ws/assistant?user_id&session_id`；
  * 会话数据表：`chat_sessions` / `messages`，与 DB 设计文档对齐。
  * 多轮对话中何时写 mem0（例如每轮对话结束时写摘要）。
  * 智能体原生编排（LangGraph）：
    * 从“上层模拟工具调用（约定 JSON → 解析 → 路由）”升级为“模型标准 tool-calls（结构化消息）+ LangGraph 自动编排”。
    * 状态采用 `MessagesState`（`messages`）作为单一事实来源：user/assistant/tool 消息统一进入消息流，便于回放、审计与评测。
    * 工具调用采用 `ToolNode`：由模型返回 tool calls 后自动执行并把结果以 tool message 形式回填。
    * 会话级 Checkpointer：按 `session_id` 线程化持久化，支持断线重连继续对话。
* Code：
  * 实现 WS handler：
    * 接收用户消息 → LangGraph（`astream_events` / `astream`）→ 流式返回（token + tool events 可选）；
    * 消息写入 `messages` 表（包含 tool 调用与 tool 返回），同时写入 mem0（摘要/偏好/结论）。
  * 将现有工具注册为 LangChain/LangGraph 工具体系（原生 tool-calls）：
    * 以 `backend/app/agents/tools/*` 为来源，把工具输入参数用 Pydantic Schema 明确化（可复用现有 `args_schema`）。
    * 通过 `StructuredTool` / `@tool` 注册（name/description/schema），并统一由 `ToolNode(tools)` 执行。
    * 模型侧通过 `model.bind_tools(tools)`（或等价方式）开启工具调用，让模型输出标准 tool calls，而不是“文本里塞 JSON”。
  * 图结构建议（最小闭环）：
    * `assistant`（调用模型，生成回复或 tool calls）→ `tools`（ToolNode 执行）→ 回到 `assistant`，直到没有 tool calls。
    * 可选节点：`memory_read`（检索 mem0 并注入上下文）、`memory_write`（回合结束写摘要）。
  * 迁移策略（尽量不推倒重来）：
    * 保留现有 `ToolRegistry` 作为“工具目录/可用性治理层”，在其上增加“导出为 LangChain tools”的适配。
    * 将原有“工具选择/工具参数归一化/解析 tool_calls”的手工逻辑逐步下线，统一收敛到 LangGraph + ToolNode。
  * Admin `/admin/chat/live`：展示当前在线会话数、最近活跃 session。
* Review：
  * 压测少量并发 WebSocket，确认不会轻易崩；
  * 一条完整对话能同时在 PostgreSQL（结构化、可回放的消息流）和 mem0（语义记忆）中被正确追踪。
  * 验证“原生 tool-calls”生效：
    * 对同一问题，模型能产出结构化 tool call（name + args），工具执行后 tool message 回填，最终回答基于 tool 输出。
    * 断线重连后，基于 `session_id` 能继续同一线程（checkpointer + messages 回放一致）。

---

### 阶段10：Android 基础 + 行程 CRUD 联调

 **目标** ：前端正式上场，先把最基础的“行程列表 / 详情 / 编辑”做起来，完全走后端真实接口。

* Spec：
  * Android 架构：MVVM + Hilt + Retrofit + Room；
  * 对接 `/api/trips` 系列接口；
* Code：
  * 完成行程列表页、详情页、基本编辑操作；
  * 本地 Room 与后端同步策略；
  * 在 Admin `/admin/api/summary` 中能看到来自 Android 的调用占比。
* Review：
  * 真机 / 模拟器上能完成一个完整的“创建行程 → 编辑 → 删除”流程。

---

### 阶段11：Android 地图 & 发现 + 智能规划/助手集成 + 总体验收

 **目标** ：把地图“发现”模块、智能规划和智能助手全部接入前端，做最终联调与验收，并为论文撰写准备数据和截图。

* Spec：
  * 集成高德地图 SDK，展示当前位置与周边 POI；
  * 前端调用 `/api/poi/around`、`/api/ai/plan`、`/ws/assistant`；
* Code：
  * 地图页 + 发现页 + 智能助手浮窗；
  * 在行程规划页中支持 fast / deep 两种模式；
  * 对接 WebSocket 行程助手，支持在行程详情页直接聊天调整行程。
* Review：
  * 跑完毕业设计展示时需要的“黄金场景”：
    * 创建行程 → 智能规划 → 地图查看 → 附近发现 → 智能助手微调行程；
  * 整理所有需要给学校的最终材料：论文、PPT、源码、视频 demo、关键截图等。
