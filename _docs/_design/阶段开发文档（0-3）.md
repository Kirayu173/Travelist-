## 阶段 0：项目基线 & 规范确定（SCR#0）

**目标**：把仓库、规范、CI 确立好，后面所有阶段都在这套“轨道”上跑。

### Spec

* 技术栈确认（和文档对齐）

  * 后端：FastAPI + PostgreSQL + Redis + LangGraph
  * 前端：Android + Kotlin + Jetpack Compose + MVVM + Retrofit + 高德 SDK
* 仓库结构：

  * `backend/app/...`
  * `frontend/android/...`
* 统一：

  * 代码风格、分支命名、Commit 规范（如 feat/bug/chore）。
  * CI 目标：至少跑单元测试 + lint。

### Code

* 初始化 FastAPI 项目骨架（空路由 + `/healthz`）。
* 初始化 Alembic（但暂时不建表）。
* 配一个最简单的 CI：拉起后端、跑 `pytest`（哪怕只有 1 个 smoke test）。

### Review

* 本地能跑：`uvicorn app.main:app` 不报错。
* CI 绿灯。
* 目录结构和现有设计文档约定一致。

---

## 阶段 1：后端管理界面基础版（项目状态监视器 v0）（SCR#1）

**目标**：在真正写业务逻辑前，先搭出一个“监控中控台”的基本壳子，让之后每个阶段都往里面挂数据。

> 注意：这个 admin 只为开发期间服务，不是最终线上运营后台。

### Spec

* 新增 `/admin` 路由前缀。
* 提供：

  * `GET /admin/ping`：简单返回版本号、当前时间等。
  * `GET /admin/api/summary`：

    * 统计最近 N 分钟 API 调用次数（先用内存计数器实现）。
  * `GET /admin/health`：

    * 返回应用基本状态：
      `{"app":"ok","db":"unknown","redis":"unknown"}`（先用 placeholder）。
* 前端展示形态：

  * 暂时可以是纯 JSON + FastAPI 自带 docs。
  * 同时准备一个简单 HTML（Jinja2）页面 `/admin/dashboard`，展示几张统计卡片（后面逐渐丰富）。

### Code

* 写一个简单的请求中间件：

  * 统计每个 API 的调用次数、最近一次耗时，存到一个 in-memory dict。
* `AdminService`：

  * 封装这些统计数据的读取。
* `admin` 路由：

  * `/admin/ping`
  * `/admin/api/summary`
  * `/admin/health`（db/redis 先写“未配置”占位）。

### Review

* 打开 `/admin/dashboard`，能看到：

  * 一些固定的信息：版本号、启动时间、API 调用计数。
* 用 Postman 打几个不同接口，刷新 dashboard，确认计数字段在变化。

> 从这一刻开始，后面所有阶段的“新能力”，都要顺手把相关监控信息挂到这个 admin 上。

---

## 阶段 2：数据库 & 核心数据模型落地（SCR#2）

**目标**：把核心表（users/trips/day_cards/sub_trips/pois 等）建起来，让后端有“真实数据”。

### Spec

* 按数据库设计文档，建：

  * `users`, `trips`, `day_cards`, `sub_trips`, `pois`, `favorites` 等。
  * 启用 PostGIS、transport ENUM。
* 在 admin 界面中增加：

  * `GET /admin/db/health`：连接测试成功/失败。
  * `GET /admin/db/stats`：输出各表的 row_count（粗略统计即可）。

### Code

* 写 Alembic migration，包含：

  * 核心表创建 + 索引 + 外键。
  * PostGIS 扩展 + ENUM 类型。
* SQLAlchemy ORM 定义：

  * `User`, `Trip`, `DayCard`, `SubTrip`, `Poi`, `Favorite` 等。
* Admin 部分：

  * `AdminService.get_db_health()`：尝试执行 `SELECT 1`。
  * `AdminService.get_db_stats()`：对几张主要表做 `COUNT(*)`（或者用 `pg_stat_user_tables`）。

### Review

* 运行 migration 没问题。
* 打 `/admin/db/health` 显示 OK。
* 打 `/admin/db/stats` 能看到表的行数（此时可能都为 0，但接口正常即可）。

---

## 阶段 3：行程 CRUD API（无智能，纯业务）+ Admin 行程统计（SCR#3）

**目标**：做一个“能维护行程的后端记事本”，并且在 admin 中能看到行程数量、最近修改时间等。

### Spec

* 行程相关 API：

  * `GET /api/trips`
  * `GET /api/trips/{trip_id}`
  * `POST /api/trips`
  * `PUT /api/trips/{trip_id}`
  * `DELETE /api/trips/{trip_id}`
* 支持：

  * DayCard/SubTrip 的基本增删改。
  * 同一天内子行程换序。
  * 跨天移动子行程。
* Admin 扩展：

  * `/admin/trips/summary`：

    * trip 总数；
    * 最近新增/修改的 trip 列表；
    * 平均每天子行程数等简单指标。

### Code

* Pydantic 模型：`TripSchema`, `DayCardSchema`, `SubTripSchema`。
* `TripService`：

  * 封装行程 CRUD、拖拽排序、换天（照数据库文档的事务示例来写）。
* API 路由 `/api/trips*` 实现。
* Admin:

  * 查询 trips / day_cards / sub_trips 统计信息；
  * 在 `/admin/dashboard` 中增加一个“行程概览”区域。

### Review

* 用 Postman 创建几个 trips，含多天多子行程，做几次换序/换天。
* 查看 `/admin/trips/summary`：

  * 数量正确；
  * 最近修改的 trip 有记录。
* 再看 `/admin/api/summary`：可以看到 `/api/trips*` 相关 API 调用次数。

---

## 阶段 4：POI & 地理服务（可用版）+ Admin POI 监控（SCR#4）

**目标**：后端支撑“附近发现”，并且 admin 能看到 POI 缓存情况和调用第三方地图 API 的频率。

### Spec

* API：

  * `GET /api/poi/around?lat&lng&type&radius`
* 功能：

  * 从高德/百度获取 POI（先真实或 mock 都可）。
  * 缓存到 Redis + 本地 `pois` 表，支持 ST_DWithin 查询。
* Admin：

  * `/admin/poi/summary`：

    * pois 表 row 数；
    * 缓存命中率（简单用计数器估算）；
    * 第三方地图 API 调用次数。

### Code

* `PoiService`：

  * 调用外部地图 API（或 mock）。
  * Redis 缓存 key：`poi:around:{lat}:{lng}:{type}:{radius}`。
  * PostGIS 查询附近：`ST_DWithin(...)`。
* API 路由 `/api/poi/around` 实现 cache-aside 逻辑。
* Admin:

  * 在中间件或 PoiService 里增加计数器：记录缓存 hit/miss 和地图 API 调用次数；
  * `/admin/poi/summary` 返回这些数据。

### Review

* 手动多次请求 `/api/poi/around`：

  * 第一轮缓存 miss，后续多次命中。
* 在 `/admin/poi/summary`：

  * 能看到 hit/miss 数变化、外部 API 调用次数增加。
* API 总览 `/admin/api/summary` 里也能看到 POI 接口的调用。

---

## 阶段 5：行程“快速模式”规划（规则生成版）+ Admin 规划统计（SCR#5）

**目标**：不依赖 LLM，根据 POI 和规则生成一个“朴素但靠谱”的行程，同时 admin 能看到规则规划的使用情况。

### Spec

* API：

  * `POST /api/ai/plan`，`mode="fast"` 时使用规则算法。
* 输入：目的地 / 起止日期 / 偏好信息。
* 输出：符合 TripSchema 的结构（可以选择是否自动入库）。
* Admin：

  * `/admin/plan/summary`：

    * fast 模式调用次数；
    * 平均行程天数；
    * 平均每日电子行程项数。

### Code

* `FastPlanner`：

  * 从 poi 表读取符合目的地/类型的 POI；
  * 按天数拆分，按距离简单排序；
  * 输出 `TripSchema` 结构。
* `POST /api/ai/plan`：

  * 识别 `mode=fast`；
  * 调 `FastPlanner`，返回 JSON；
  * 可选：加一个参数 `save=true` 时落库成真正的 trip。
* Admin：

  * 统计 fast 规划请求次数/失败次数；
  * 汇总生成行程的平均天数，展示在 `/admin/plan/summary`。

### Review

* 用几组目的地和日期实测 fast 模式：

  * 行程结构完整、无空天。
* 在 `/admin/plan/summary`：

  * 能看到 fast 模式调用统计；
  * 配合 `/admin/api/summary` 验证数据一致。

---

## 阶段 6：LLM Provider 接入 & LangGraph 骨架 + Admin AI 基础监控（SCR#6）

**目标**：接入 LLM + LangGraph 基本骨架，跑通一个简单的 ai-chat demo，并在 admin 里能看见 LLM 调用数量与耗时。

### Spec

* LangGraph：

  * 基础节点：`AssistantNode` + `ResponseFormatter`。
* LLM 客户端：

  * `AiClient.generate(prompt, schema=None)`。
* API：

  * `POST /api/ai/chat_demo`：简单 echo + LLM 回答。
* Admin：

  * `/admin/ai/summary`：

    * LLM 调用总次数；
    * 平均耗时；
    * 错误率。

### Code

* 实现 LLM provider（比如通过 OpenAI/其他）；
* LangGraph 初版：

  * 输入：用户消息；
  * 输出：简单文本回复。
* `/api/ai/chat_demo` 调 LangGraph；
* Admin：

  * 在 AiClient 里加统计（调用次数 / 耗时 / 异常次数）。
  * `/admin/ai/summary` 返回这些指标。

### Review

* 调 `/api/ai/chat_demo`：

  * 能收到 LLM 回答。
* 看 `/admin/ai/summary`：

  * 调用次数和耗时有统计，错误率为 0 或合理数值。

---

## 阶段 7：AI 行程“深度模式”生成 + 异步任务 & Admin 任务监控（SCR#7）

**目标**：让 LLM 正式参与行程生成（deep 模式），支持异步任务，admin 能看到 ai 任务的状态分布。

### Spec

* 扩展 `POST /api/ai/plan`：

  * `mode="deep"`：调用 LangGraph 中的 `PlannerNode` + LLM；
  * 支持 `async=true`：返回 `task_id`。
* 数据库：

  * `ai_tasks` 表，用于记录异步任务状态 / 结果。
* Admin：

  * `/admin/ai/tasks`：

    * 显示任务数：pending/running/done/failed；
    * 最近 N 条任务的简要信息。

### Code

* LangGraph：

  * 完善 `PlannerNode`：构造 prompt、调 LLM 输出 JSON；
  * 增加 ResponseValidator 解析到 TripSchema。
* `ai_tasks` ORM + migration。
* 后台 worker（简单 arq / 内部协程队列）：

  * 轮询 pending 任务，调用 PlannerNode，写回 result。
* 拓展 `/api/ai/plan` 与 `GET /api/ai/tasks/{id}`。
* Admin：

  * `AdminService.get_ai_task_stats()`；
  * `/admin/ai/tasks` 页面/JSON 展示。

### Review

* 调 deep 模式生成：

  * 拿到 task_id；
  * 过一会儿请求 `/api/ai/tasks/{id}`，有 result；
  * 或直接在 DB 查 result。
* `/admin/ai/tasks`：

  * 能看到任务状态数量变化。

---

## 阶段 8：智能助手基础问答（REST 单轮）+ Admin 会话统计（SCR#8）

**目标**：做一个有工具调用能力的 QA 接口，并在 admin 看到会话数/问题类型分布。

### Spec

* API：

  * `POST /api/ai/chat`：单轮问答。
* 功能：

  * 支持读取 trip / poi / weather 等工具；
  * 按意图调用相关节点。
* 数据表：

  * `chat_sessions` / `messages`（至少用于记录一部分）
* Admin：

  * `/admin/chat/summary`：

    * 会话总数；
    * 问题量；
    * 大致意图分布（简易：在 message.meta 里标记 intent，然后 group by）。

### Code

* LangGraph 扩展：

  * 加 `intent_parser`、`PoiNode`、`TripQueryNode`、`WeatherNode` 等。
* `AssistantService.chat_once(...)`：

  * 包装 LangGraph 调用。
* `/api/ai/chat`：

  * 接收 user_id/可选 trip_id + 问题。
  * 写入 `chat_sessions` / `messages`（简化也可以只记 user/assistant 各一条）。
* Admin：

  * 汇总 chat_sessions/messages；
  * 简单以意图字段统计数量。

### Review

* 对 `/api/ai/chat` 发几个问题：

  * 和 trip 相关、和 POI 相关；
  * 验证工具调用路径是否正确（看日志）。
* 在 `/admin/chat/summary`：

  * 能看到会话数/消息数增长。

---

## 阶段 9：智能助手 WebSocket 多轮对话 + Admin 实时连接数（SCR#9）

**目标**：上 WebSocket，多轮聊天，并在 admin 界面看当前在线聊天数。

### Spec

* WebSocket：

  * `WS /ws/assistant?user_id&session_id`。
* 能力：

  * 多轮对话；
  * 流式输出。
* Admin：

  * `/admin/chat/live`：

    * 当前活跃 WebSocket 连接数；
    * 最近活跃 session 列表。

### Code

* 实现 WebSocket handler：

  * 收用户消息 → LangGraph → 流式返回。
  * 消息落 `messages` 表 / Redis。
* 在内存 / Redis 维护活跃 WebSocket session 列表。
* Admin：

  * `AdminService.get_live_chat_stats()`；
  * `/admin/chat/live` 显示当前在线会话数 + 简单列表。

### Review

* 用测试客户端开几条 WS 对话，发消息；
* `/admin/chat/live` 能实时反映数量变化；
* 当客户端断开时，会话被正确从“活跃列表”中删除。

---

## 阶段 10：Android 基础框架 & 行程列表/详情（SCR#10）

**目标**：前端终于上场，先接最基础的行程 CRUD，确保“能看能改”，后端 admin 同样能看到来自移动端的调用。

### Spec

* Android 架构：

  * MVVM + Hilt + Retrofit + Room。
* 页面：

  * 行程列表 + 行程详情。
* 功能：

  * 拉取 `/api/trips`；
  * 新增 / 编辑 / 删除 Trip；
  * 触发后端的换序/换天。

### Code

* 初始化 Android 工程；
* Retrofit 接入后端；
* Room 定义本地 Trip/DayCard/SubTrip；
* `TripRepository` 同步后端与本地；
* `TripViewModel` + Compose UI。

### Review

* 模拟器/真机：

  * 能创建/查看/修改行程；
* 后端 `/admin/api/summary`：

  * 能看到来自 Android 的调用统计。

---

## 阶段 11：地图 & 发现模块 + 行程规划 UI（SCR#11）

**目标**：前端地图 + 附近发现 + 行程卡片 UI 接起来，后台 POI 与行程能力被完整消费。

### Spec

* Android：

  * 地图页：当前位置 + 附近 POI；
  * 行程规划页：卡片式展示行程。
* 功能：

  * 调 `/api/poi/around`；
  * 把 POI 加入行程；
  * 跳导航 APP。

### Code

* 集成高德 Map SDK；
* 实现 Map 页面 + Marker；
* 通过 Retrofit 调后端 POI 接口；
* 行程规划 UI 改成卡片风格；
* 支持“将 POI 添加到某天子行程”。

### Review

* 手机上看：

  * 地图加载 + Marker 展示正常；
  * 点击 POI → 加入行程成功；
  * 后端 `/admin/poi/summary` 能看到调用和缓存变化。

---

## 阶段 12：智能规划 & 智能助手前端整合 + 全链路验收（SCR#12）

**目标**：把 fast/deep 行程生成、WebSocket 智能助手和行程卡片 UI 全部打通，做总体验收；Admin 作为统一监控面板收尾。

### Spec

* 行程规划页：

  * 用户选择 fast / deep 模式生成；
  * 对 deep 支持任务轮询或者 WS 通知。
* 智能助手浮窗：

  * 在多个页面右下角悬浮；
  * 对接 `/ws/assistant`；
  * 在行程页自动携带 trip_id。
* Admin：

  * `/admin/dashboard` 展示：

    * API 概览；
    * DB/Redis 状态；
    * 行程/POI/AI 任务/Chat 会话的组合统计。

### Code

* 前端：

  * 接 `POST /api/ai/plan`；
  * 对 deep 模式做 loading + 轮询/推送；
  * 聊天 UI：流式显示回复。
* 后端：

  * 确保所有 admin 接口稳定；
  * 优化 dashboard 展示，做一个“总览页面”。

### Review

* 用一条完整场景自测：

  1. 在 APP 中选目的地和日期 → fast 生成行程；
  2. 再用 deep 模式生成，比较两者；
  3. 地图页查看附近 POI 并加入行程；
  4. 打开智能助手，发多轮消息，调整行程；
  5. 打开 `/admin/dashboard` 看全链路数据是否都在动：API 调用、行程数、POI 缓存、AI 任务、Chat 会话。

---
