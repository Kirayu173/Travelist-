# 数据库设计文档（PostgreSQL + PostGIS + Redis）

> 目标：为“智能旅游”后端提供一份全面、详细、可执行的数据库设计规范，覆盖逻辑/物理模型、建表 DDL、索引/分区/性能策略、并发/事务流程、Redis 键设计与缓存模式、迁移/备份/监控和测试建议，直接指导开发与运维。本文基于现有产品与技术文档的功能约定与架构假设编写并与之保持一致。

---

# 1 设计原则（概要）

1. **以实体+事件为主** ：核心主表（用户、行程、POI、会话）采用关系化强约束；聊天/消息等写放大数据采用分表/Partition 或 Redis/Stream 层做热数据缓存。
2. **地理空间优先** ：POI 与位置点使用 PostGIS `geography` 类型，带 GiST 索引支持附近检索与路线点。
3. **结构化 + 灵活扩展** ：对于第三方回包或 LLM 结果使用 `JSONB`（并配合 GIN 索引做必要查询与筛选）。
4. **可复现实验/审计** ：生成/修改行为记录审计日志（便于论文复现）。
5. **高可用与可维护** ：考虑备份、读写分离、监控、迁移策略及表维护（VACUUM、REINDEX、ANALYZE）。

---

# 2 概览 ER（文本版）

主要实体：

* `users` ← 1:N → `trips` ← 1:N → `day_cards` ← 1:N → `sub_trips`
* `pois` (master POI 表)
* `favorites` (用户收藏)
* `chat_sessions` ← 1:N → `messages`（消息）
* `ai_tasks`（异步任务状态/结果）
* 辅助：`attachments`、`audit_logs`、`rate_limits` 等

（上层设计与产品模块、智能体交互等一一对应，参见产品说明与智能体编排文档）。

---

# 3 PostgreSQL 详细 Schema（核心表+DDL 範例）

> 说明：以下字段包含类型、约束、索引建议与注释。所有表建议加 `created_at TIMESTAMPTZ DEFAULT now()`、`updated_at TIMESTAMPTZ`（触发器/应用层维护）。

```sql
-- 扩展与类型
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ENUM 类型
CREATE TYPE transport AS ENUM ('walk','bike','drive','transit');
```

## 3.1 users

```sql
CREATE TABLE users (
  id BIGSERIAL PRIMARY KEY,
  uuid UUID DEFAULT uuid_generate_v4() UNIQUE,
  email TEXT UNIQUE NOT NULL,
  name TEXT,
  phone TEXT,
  preferences JSONB DEFAULT '{}'::jsonb,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ
);
CREATE INDEX idx_users_email_lower ON users (lower(email));
```

说明：email 提供唯一性；`preferences` 用 JSONB 存长期偏好（可用 GIN 索引按需）。

## 3.2 trips

```sql
CREATE TABLE trips (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  title TEXT,
  destination TEXT,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  status TEXT DEFAULT 'active',
  meta JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ
);
CREATE INDEX idx_trips_user ON trips(user_id);
```

## 3.3 day_cards

```sql
CREATE TABLE day_cards (
  id BIGSERIAL PRIMARY KEY,
  trip_id BIGINT NOT NULL REFERENCES trips(id) ON DELETE CASCADE,
  day_index INT NOT NULL, -- 0-based or 1-based 全团队约定
  date DATE,
  note TEXT,
  UNIQUE (trip_id, day_index)
);
CREATE INDEX idx_daycards_trip ON day_cards(trip_id);
```

## 3.4 sub_trips（子行程项）

```sql
CREATE TABLE sub_trips (
  id BIGSERIAL PRIMARY KEY,
  day_card_id BIGINT NOT NULL REFERENCES day_cards(id) ON DELETE CASCADE,
  order_index INT NOT NULL,
  activity TEXT NOT NULL,             -- 标题或类型
  poi_id BIGINT REFERENCES pois(id),  -- 可选 link 到 poi
  loc_name TEXT,
  transport transport,
  start_time TIMESTAMPTZ,
  end_time TIMESTAMPTZ,
  geom geography(Point,4326),  -- PostGIS
  ext JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ,
  UNIQUE (day_card_id, order_index)
);
CREATE INDEX idx_subtrips_day_order ON sub_trips(day_card_id, order_index);
CREATE INDEX idx_subtrips_geom ON sub_trips USING GIST (geom);
```

## 3.5 pois（POI 主表）

```sql
CREATE TABLE pois (
  id BIGSERIAL PRIMARY KEY,
  provider TEXT,            -- e.g., gaode
  provider_id TEXT,         -- 第三方ID
  name TEXT NOT NULL,
  category TEXT,
  addr TEXT,
  rating NUMERIC(3,2),
  geom geography(Point,4326),
  ext JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ
);
CREATE INDEX idx_pois_geom ON pois USING GIST (geom);
CREATE INDEX idx_pois_provider_pid ON pois(provider, provider_id);
CREATE INDEX idx_pois_name_trgm ON pois USING GIN (to_tsvector('simple', name));
```

说明：`ext` 存第三方回包；`to_tsvector` 用于快速文本搜索（也可用 pg_trgm）。

## 3.6 favorites

```sql
CREATE TABLE favorites (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  poi_id BIGINT NOT NULL REFERENCES pois(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(user_id, poi_id)
);
```

## 3.7 chat_sessions & messages（消息量大，需分表/分区）

```sql
CREATE TABLE chat_sessions (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE SET NULL,
  trip_id BIGINT REFERENCES trips(id),
  opened_at TIMESTAMPTZ DEFAULT now(),
  closed_at TIMESTAMPTZ,
  meta JSONB DEFAULT '{}'::jsonb
);

-- messages 建议按时间分区 (按 month 或按 year)
CREATE TABLE messages (
  id BIGSERIAL PRIMARY KEY,
  session_id BIGINT NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE,
  role TEXT NOT NULL,  -- user/system/assistant
  content TEXT NOT NULL,
  tokens INT,
  created_at TIMESTAMPTZ DEFAULT now()
);
-- 分区建议：使用 declarative partitioning （按 created_at RANGE）
```

 **分区建议** ：消息表采用 RANGE 分区（monthly）或基于 `created_at` 的时序分区；可保留近 6–12 个月热数据在主库，历史归档到冷表或数据仓库。

## 3.8 ai_tasks（异步任务）

```sql
CREATE TABLE ai_tasks (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT REFERENCES users(id),
  kind TEXT NOT NULL,  -- e.g., plan:deep
  payload JSONB,       -- 请求参数
  status TEXT,         -- pending/running/done/failed
  result JSONB,        -- 结构化结果或错误信息
  created_at TIMESTAMPTZ DEFAULT now(),
  finished_at TIMESTAMPTZ
);
CREATE INDEX idx_ai_tasks_user ON ai_tasks(user_id);
CREATE INDEX idx_ai_tasks_status ON ai_tasks(status);
```

---

# 4 索引、查询与 PostGIS 使用范例

## 4.1 POI 附近检索（示例）

* 使用 `ST_DWithin(geom::geography, ST_MakePoint(lon, lat)::geography, radius_m)` 优化附近检索（距离以米为单位）。

```sql
SELECT id, name, ST_Distance(geom, ST_MakePoint(:lon, :lat)::geography) AS dist_m
FROM pois
WHERE ST_DWithin(geom, ST_MakePoint(:lon, :lat)::geography, :radius_m)
ORDER BY dist_m
LIMIT 50;
```

* 需确保 `geom` 上存在 GiST 索引。

## 4.2 行程详情一次性查询（聚合 DTO）

```sql
SELECT t.*, json_agg(dc ORDER BY dc.day_index) AS days
FROM trips t
LEFT JOIN (
  SELECT d.*, (
    SELECT json_agg(st ORDER BY st.order_index) FROM sub_trips st WHERE st.day_card_id = d.id
  ) AS sub_trips
  FROM day_cards d WHERE d.trip_id = t.id
) dc ON dc.trip_id = t.id
WHERE t.id = :trip_id
GROUP BY t.id;
```

说明：繁重聚合建议在后端或视图中分批查询以避免性能抖动。

---

# 5 并发、事务与数据一致性模式

## 5.1 排序（拖拽换序）与换天操作（事务范例）

* **原则** ：对涉及的两组 `sub_trips` 使用单事务+行级锁（`SELECT ... FOR UPDATE`）或使用 `advisory_lock` 防止并发冲突。
* **示例事务** （伪 SQL）：

```sql
BEGIN;
-- 锁定源与目标 day_card 行
SELECT id FROM sub_trips WHERE day_card_id = :src_day FOR UPDATE;
SELECT id FROM sub_trips WHERE day_card_id = :dst_day FOR UPDATE;

-- 批量调整 order_index（建议在应用层计算新的 index 并批量 UPDATE）
UPDATE sub_trips SET day_card_id = :dst_day, order_index = :new_index WHERE id = :moved_id;
COMMIT;
```

* **优化** ：避免逐条 shift，而是按需要重序（compact indexes），并在失败时做幂等重试。

## 5.2 乐观并发

* 在需要时为关键行（如 `trips`）增加 `version` 或 `updated_at` 字段，使用条件更新保证幂等。例：

```sql
UPDATE trips SET title = :title, updated_at = now()
WHERE id = :id AND updated_at = :old_updated_at;
```

## 5.3 长事务与异步任务

* LLM 深度生成走 `ai_tasks` 异步流，避免占用 DB 长时锁；结果写回时用短事务更新 `trips` 与 `ai_tasks` 状态。

---

# 6 Redis 设计与缓存策略（热数据 + 限流 + 会话）

## 6.1 Redis 键设计与 TTL 建议（命名空间）

* `poi:around:{lat}:{lng}:{type}:{radius}` → JSON list，TTL 600（10min）。
* `route:{trip_id}:{day}` → route cache，TTL 1800（30min）。
* `chat:session:{sid}:stream` → Redis Stream（或 List）保存最近 N 条消息；用于快速加载与 WS 推送。
* `ai:task:{id}` → 状态（pending/running/done）+ progress metadata，TTL 否（持久直到 task done then persist to PG）。
* `rl:{user_id}:{api}` → 速率限制滑窗计数，TTL 按限流窗口（秒）。
* `session:ws:{session_id}` → WebSocket 连接元数据短期存储（TTL 600s）。

## 6.2 缓存模式

* **Cache-aside（推荐）** ：读取时先查 Redis → miss 则查询 PG 并写回 Redis。适用于 POI、route。
* **Write-through / Write-behind（慎用）** ：写操作同时更新 Redis 与 PG，复杂并发下易出现不一致。建议仅对非关键最终一致性缓存使用。
* **Session & Chat** ：短期热数据用 Redis（Stream 或 List），在合适时落库（批次/TTL 异步持久化到 `messages` 表）。这样能减少 DB 写冲击并保留热读性能。

## 6.3 限流与熔断

* 基于 Redis 的滑动窗口（ZSET）或计数器实现 API 限流；对 `ai/*` 接口设置更严格的配额。

---

# 7 分区、归档与清理策略

## 7.1 分区建议

* `messages`：按 `created_at` RANGE monthly 分区（或 weekly 若高 QPS）。
* `ai_tasks`：按 `created_at` 分区或定期清理/归档（将老数据转移到数据仓库）。
* `pois`：通常不分区（相对稳定），但若数据量巨大可按 `provider` 分区。

## 7.2 冷/热数据策略

* 热数据保留在主库并有较高备份频率；冷数据（数年历史聊天）定期导入数据仓库（例如 CSV/Parquet 到对象存储）并从主库删除/归档。

## 7.3 自动清理

* 设置维护脚本：`VACUUM ANALYZE`、`REINDEX`、分区轮转任务、历史数据归档任务（Cron + 管理脚本）。

---

# 8 迁移、版本控制与 CI/CD

## 8.1 Alembic 迁移策略

* 每次变更（DDL）用 Alembic 生成 migration 文件并在 CI 里运行测试迁移。
* 在重要变更（列重命名、类型改动）使用线下脚本：
  1. 增加新列（兼容旧写）
  2. 后端写双写（旧列，新列）若有需要
  3. 数据填充（batch background job）
  4. 切换读取到新列
  5. 删除旧列（后续迁移）

## 8.2 回滚

* 每个 migration 保持可逆或提供 backfill/rollback 脚本，测试 rollback 在 CI 环境中执行一次。

---

# 9 备份、恢复与高可用

## 9.1 备份

* PG：`pg_basebackup`（物理备份）+ `pg_dump`（logical）结合 WAL 归档策略。定期快照与增量保留策略（7/30/365）。
* Redis：RDB 或 AOF，根据缓存重要性选择。Session/Chat 热数据如果极重要，用 AOF；否则 RDB 并配合复制。

## 9.2 恢复演练

* 定期做恢复演练（至少每季度）并在 runbook 中记录 RTO/RPO 目标（例如 RTO 1h，RPO 15min 视业务决定）。

## 9.3 高可用

* PG：主从（primary-replica） + 自动故障切换（Patroni 等）或云托管（RDS、Cloud SQL）。
* Redis：主从 + Sentinel 或 Cluster 模式（若需要分片）。

---

# 10 安全与合规（数据隐私、访问控制）

1. **最小权限** ：数据库用户分角色（readonly/reporting/worker/admin）。
2. **加密** ：传输层 TLS；敏感字段（手机号、email）可考虑列级加密或在应用层加密。
3. **审计** ：对关键表操作记录 `audit_logs`（user_id、action、before/after）。
4. **数据删除/保留** ：实现 GDPR 风格的“删除/匿名化”流程（数据标记→异步清理/脱敏）。
5. **密钥管理** ：使用 Vault/KMS 管理数据库/第三方 API 密钥（后端不在源码中保存）。

---

# 11 指标、监控与调优

## 11.1 要监控的关键指标

* PG：connections, xact_commit/rollback, long running queries, locks, cache hit ratio, bloat（pg_stat_user_tables, pg_stat_statements）。
* Redis：hit ratio, memory usage, evictions, latency。
* 业务：API QPS、P95/P99 响应、LLM 平均耗时、WS 会话数。

## 11.2 工具与报警

* Prometheus + Grafana；使用 `pg_exporter`、`redis_exporter`、`node_exporter`。
* 建议告警：长查询 > 5s、空闲连接数达阈值、Redis memory > 80%、replica lag > 10s。

---

# 12 测试与验收（数据库层）

1. **单元测试** ：对 DAO/Repository 层用事务回滚或 Testcontainers 测试（在 CI 中运行）。
2. **集成测试** ：终端到终端（FastAPI + PG + Redis），覆盖行程 CRUD、POI 查询、消息持久化。
3. **性能测试** ：模拟高并发行程生成场景（含 LLM 任务并发），评估 DB 写放大点（messages/ai_tasks）。
4. **回归/迁移测试** ：在迁移分支跑迁移脚本并测试回退。

---

# 13 实用 SQL 样例（常见操作）

## 13.1 安全批量重排 order_index（伪代码）

```sql
-- 应用层计算 new order_index 列表，然后在单事务里批量更新
BEGIN;
UPDATE sub_trips SET order_index = v.new_index
FROM (VALUES
  (1, 10),
  (2, 20)
) AS v(id, new_index)
WHERE sub_trips.id = v.id;
COMMIT;
```

## 13.2 使用 advisory lock 防止并发

```sql
-- 在应用层，先获得一个基于 trip_id 的 advisory lock
SELECT pg_advisory_lock(hashtext('trip_order_' || :trip_id));
-- 执行重排
SELECT pg_advisory_unlock(hashtext('trip_order_' || :trip_id));
```

## 13.3 POI 模糊搜索（tsvector）

```sql
-- 建立 tsvector 列并索引（维护任务或触发器生成）
ALTER TABLE pois ADD COLUMN name_tsv tsvector;
UPDATE pois SET name_tsv = to_tsvector('simple', coalesce(name,''));
CREATE INDEX idx_pois_name_tsv ON pois USING GIN(name_tsv);
-- 查询
SELECT * FROM pois WHERE name_tsv @@ plainto_tsquery('simple', :q) LIMIT 50;
```

---

# 14 持续演进与交付建议（落地实施步骤）

1. **基础建表（里程碑 A）** ：users/trips/day_cards/sub_trips/pois + 基本索引 + PostGIS 扩展。
2. **Redis 快速路径（里程碑 B）** ：POI 缓存、chat session 热数据设计、限流 key。
3. **消息分区/归档（里程碑 C）** ：按流量设计 messages 的分区策略并实现归档任务。
4. **异步任务与 LangGraph 整合（里程碑 D）** ：ai_tasks + 后台 worker + WS 流式写回。
5. **性能/监控/备份（里程碑 E）** ：Prometheus 仪表盘、备份演练、灾备流程。

---

# 15 附录：交付件清单（交付给开发/运维）

* 完整 SQL DDL（当前版本） + Alembic migration 文件样例
* ORM 映射（SQLAlchemy）骨架（含 geoalchemy2 映射）
* Redis key 列表与 TTL 文档（JSON）
* 分区、归档与备份 Runbook（操作步骤）
* 测试用 DB 镜像 / CI 脚本（Testcontainers 或 docker-compose）
* 监控面板（Prometheus/Grafana 导出 JSON）与报警规则
* 数据隐私与审计策略文件（包含示例 SQL）

---
